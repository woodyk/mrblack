#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# File: release.py
# Author: Wadih Khairallah
# Description: 
# Created: 2025-05-17 20:55:02
# Modified: 2025-05-17 21:25:37

import os
import sys
import subprocess
import argparse
import json
import re
from pathlib import Path

# -----------------------------------------------------------------------------
# CONFIGURATION
# -----------------------------------------------------------------------------
CONFIG = {
    "package_name": "mrblack",
    "version_module": "mrblack/__version__.py",
    "readme": "README.md",
    "license": "LICENSE",
    "requirements": "requirements.txt",
    "docs_output": "docs/",
    "author_name": "Wadih Khairallah",
    "author_email": "woodyk@gmail.com",
    "project_url": "https://github.com/woodyk/mrblack",
    "description": "Data extraction and analysis toolkit.",
    "python_requires": ">=3.8",
    "license_text": "MIT",
    "keywords": ["text", "extraction", "pii", "analysis"],
    "classifiers": [
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent"
    ],
    "scripts": {
        "mrblack": "mrblack.cli:main",
        "pii": "mrblack.pii:main",
        "textextract": "mrblack.textextract:main"
    },
    "data_dirs": [],
    "packages_find": {
        "where": ["."],
        "include": ["mrblack", "mrblack.*"]
    },
    "include_package_data": True,
    "venv_dir": ".venv",
    "required_tools": ["build", "twine", "pdoc"],
    "build_command": "python3 -m build",
    "upload_command": "python3 -m twine upload dist/*",
    "vcs_push_branch": "main"
}

# -----------------------------------------------------------------------------
# STATE TRACKING
# -----------------------------------------------------------------------------
FAILED_STEPS = []

# -----------------------------------------------------------------------------
# ENVIRONMENT SETUP
# -----------------------------------------------------------------------------

def setup_venv():
    venv = Path(CONFIG["venv_dir"])
    if not venv.exists():
        print(f"üì¶ Creating virtual environment at {venv}/")
        subprocess.run([sys.executable, "-m", "venv", str(venv)], check=True)

    pip = venv / "bin" / "pip"
    python = venv / "bin" / "python"

    print("üì¶ Installing release tools...")
    subprocess.run([str(pip), "install", "--upgrade", "pip", "setuptools"], check=True)
    subprocess.run([str(pip), "install"] + CONFIG["required_tools"], check=True)

    return str(python)

def install_project_requirements(python_exe: str):
    pip_exe = Path(python_exe).parent / "pip"
    print("üì¶ Installing project dependencies from requirements.txt...")
    subprocess.run([str(pip_exe), "install", "-r", CONFIG["requirements"]], check=True)

# -----------------------------------------------------------------------------
# UTILITIES
# -----------------------------------------------------------------------------

def extract_version():
    content = Path(CONFIG["version_module"]).read_text(encoding="utf-8")
    match = re.search(r'__version__\s*=\s*[\'"]([^\'"]+)[\'"]', content)
    if not match:
        sys.exit("ERROR: __version__ not found.")
    return match.group(1)

def read_requirements():
    return [
        line.strip()
        for line in Path(CONFIG["requirements"]).read_text(encoding="utf-8").splitlines()
        if line.strip() and not line.startswith("#")
    ]

def render_pyproject(version, dependencies):
    lines = [
        "# AUTO-GENERATED BY release.py ‚Äî DO NOT EDIT",
        "[build-system]",
        'requires = ["setuptools>=61.0"]',
        'build-backend = "setuptools.build_meta"',
        "",
        "[project]",
        f'name = "{CONFIG["package_name"]}"',
        f'version = "{version}"',
        f'description = "{CONFIG["description"]}"',
        f'readme = {{ file = "{CONFIG["readme"]}", content-type = "text/markdown" }}',
        f'requires-python = "{CONFIG["python_requires"]}"',
        f'license = {{ text = "{CONFIG["license_text"]}" }}',
        "authors = [",
        f'  {{ name = "{CONFIG["author_name"]}", email = "{CONFIG["author_email"]}" }}',
        "]",
        f'keywords = {json.dumps(CONFIG["keywords"])}',
        "classifiers = ["
    ] + [f'  "{c}",' for c in CONFIG["classifiers"]] + [
        "]",
        "dependencies = ["
    ] + [f'  "{dep}",' for dep in dependencies] + [
        "]",
        "",
        "[project.urls]",
        f'Homepage = "{CONFIG["project_url"]}"',
        "",
        "[project.scripts]"
    ] + [f'{k} = "{v}"' for k, v in CONFIG["scripts"].items()] + [
        "",
        "[tool.setuptools]",
        f"include-package-data = {str(CONFIG["include_package_data"]).lower()}",
        "",
        "[tool.setuptools.packages.find]",
        f'where = {json.dumps(CONFIG["packages_find"]["where"])}',
        f'include = {json.dumps(CONFIG["packages_find"]["include"])}'
    ]
    return "\n".join(lines)

def render_manifest():
    lines = [
        "# AUTO-GENERATED BY release.py ‚Äî DO NOT EDIT",
        f"include {CONFIG['readme']}",
        f"include {CONFIG['license']}",
        f"include {CONFIG['requirements']}",
        "include pyproject.toml",
        "include MANIFEST.in"
    ] + [f"recursive-include {d} *" for d in CONFIG["data_dirs"]] + [
        "global-exclude __pycache__ *.py[co]"
    ]
    return "\n".join(lines)

def run(cmd: str, step_name: str, allow_fail=False):
    print(f"‚ñ∂ {cmd}")
    try:
        subprocess.run(cmd, shell=True, check=True)
    except subprocess.CalledProcessError as e:
        msg = f"‚ùå Step '{step_name}' failed with exit code {e.returncode}."
        FAILED_STEPS.append((step_name, msg))
        print(msg)
        if not allow_fail:
            sys.exit(e.returncode)

# -----------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------

def main(dry_run=False):
    python = setup_venv()
    install_project_requirements(python)
    version = extract_version()
    deps = read_requirements()
    pyproject = render_pyproject(version, deps)
    manifest = render_manifest()

    if dry_run:
        print("\n=== VERSION ===")
        print(version)
        print("\n=== DEPENDENCIES ===")
        print("\n".join(deps))
        print("\n=== pyproject.toml ===")
        print(pyproject)
        print("\n=== MANIFEST.in ===")
        print(manifest)
        print("\n‚úÖ Dry run complete.")
        return

    print("üßº Cleaning old builds...")
    for folder in ["dist", "build", f"{CONFIG['package_name']}.egg-info"]:
        run(f"rm -rf {folder}", "clean")

    print("üìÑ Writing pyproject.toml and MANIFEST.in...")
    Path("pyproject.toml").write_text(pyproject + "\n", encoding="utf-8")
    Path("MANIFEST.in").write_text(manifest + "\n", encoding="utf-8")

    print("üìö Building documentation...")
    Path(CONFIG["docs_output"]).mkdir(exist_ok=True)
    run(f"{python} -m pdoc -d markdown -o {CONFIG['docs_output']} {CONFIG['package_name']}", "docs")

    print("üì¶ Building package...")
    run(f"{python} -m build", "build")

    print("‚¨ÜÔ∏è  Uploading to PyPI...")
    run(f"{python} -m twine upload dist/*", "upload", allow_fail=True)

    print("üìç Git commit and tag...")
    run(f'git commit -am "Release v{version}"', "git-commit", allow_fail=True)
    run(f"git tag v{version}", "git-tag", allow_fail=True)
    run(f"git push origin {CONFIG['vcs_push_branch']} --tags", "git-push", allow_fail=True)

    # Summary
    print("\nüßæ Release Summary")
    if FAILED_STEPS:
        for step, msg in FAILED_STEPS:
            print(f"‚ö†Ô∏è  {msg}")
        print("‚ö†Ô∏è  Review the above issues before considering this release final.")
    else:
        print("‚úÖ All steps completed successfully.")

# -----------------------------------------------------------------------------
# ENTRY POINT
# -----------------------------------------------------------------------------

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Release automation with .venv, docgen, and summary")
    parser.add_argument("--dry-run", action="store_true", help="Preview release files and metadata only")
    args = parser.parse_args()
    main(dry_run=args.dry_run)

